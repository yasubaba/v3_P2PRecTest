"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SkyWayAuthToken = void 0;
const common_1 = require("@skyway-sdk/common");
const jsrsasign_1 = __importDefault(require("jsrsasign"));
const jwt_decode_1 = __importDefault(require("jwt-decode"));
const zod_1 = require("zod");
// import { fromZodError } from 'zod-validation-error'; // 下記にかいてある理由によりコメントアウト
const _1 = require(".");
const log = new common_1.Logger('packages/token/src/encoder.ts');
class SkyWayAuthToken {
    constructor(props) {
        let parsedProps;
        try {
            parsedProps = _1.AuthTokenSchema.parse(props);
        }
        catch (error) {
            if (error instanceof zod_1.z.ZodError) {
                // TODO: zod-validation-errorを利用するとkarmaでエラーが発生するため，今後エラーメッセージ生成の対応をする
                /**
                const validationError = fromZodError(error);
                throw new SkyWayError({
                  path: log.prefix,
                  info: {
                    ...tokenErrors.invalidParameter,
                    detail: validationError.toString(), // detailをzodでのvalidationエラーに変更
                  },
                  error: validationError,
                });
                */
                throw new common_1.SkyWayError({
                    path: log.prefix,
                    info: _1.tokenErrors.invalidParameter,
                    error: new Error('Received invalid token. Please check your SkyWayAuthToken.'),
                });
            }
            else {
                throw new common_1.SkyWayError({
                    path: log.prefix,
                    info: _1.tokenErrors.invalidParameter,
                    error: new Error('Received invalid token. Please check your SkyWayAuthToken.'),
                });
            }
        }
        Object.assign(this, parsedProps);
    }
    static Decode(token) {
        try {
            const props = (0, jwt_decode_1.default)(token);
            const authToken = new SkyWayAuthToken(props);
            authToken.tokenString = token;
            return authToken;
        }
        catch (error) {
            throw new common_1.SkyWayError({
                path: log.prefix,
                info: _1.tokenErrors.invalidParameter,
                error,
            });
        }
    }
    encode(secret) {
        const payload = {
            jti: this.jti,
            iat: this.iat,
            exp: this.exp,
            scope: this.scope,
            version: this.version,
        };
        this.tokenString = jsrsasign_1.default.KJUR.jws.JWS.sign('HS256', JSON.stringify({ alg: 'HS256', typ: 'JWT' }), JSON.stringify(payload), secret);
        return this.tokenString;
    }
    /**@internal */
    toJSON() {
        return {
            jti: this.jti,
            iat: this.iat,
            exp: this.exp,
            scope: this.scope,
            encoded: this.tokenString,
            version: this.version,
        };
    }
    /**@internal */
    getAppId() {
        switch (this.version) {
            case undefined:
            case 1:
            case 2: {
                const scope = this.scope;
                return scope.app.id;
            }
            case 3: {
                const scope = this.scope;
                return scope.appId;
            }
            default:
                throw new common_1.SkyWayError({
                    path: log.prefix,
                    info: _1.tokenErrors.invalidParameter,
                    error: new Error(`invalid token version: version ${this.version} is not supported.`),
                });
        }
    }
    /**@internal */
    getAnalyticsEnabled() {
        var _a, _b, _c;
        switch (this.version) {
            case undefined:
            case 1:
            case 2: {
                const scope = this.scope;
                return (_a = scope.app.analytics) !== null && _a !== void 0 ? _a : false;
            }
            case 3: {
                const scope = this.scope;
                return (_c = (_b = scope.analytics) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : true;
            }
            default:
                throw new common_1.SkyWayError({
                    path: log.prefix,
                    info: _1.tokenErrors.invalidParameter,
                    error: new Error(`invalid token version: version ${this.version} is not supported.`),
                });
        }
    }
}
exports.SkyWayAuthToken = SkyWayAuthToken;
//# sourceMappingURL=encoder.js.map